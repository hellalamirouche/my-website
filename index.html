
<html><head><base href="https://peer-chat.websim.ai/"><title>Advanced P2P Live Streaming Platform</title><style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 20px;
    background-color: #f0f0f0;
  }
  .container {
    max-width: 1200px;
    margin: 0 auto;
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  h1, h2 {
    color: #333;
  }
  #videoElement {
    width: 100%;
    background-color: #ddd;
  }
  .controls {
    margin-top: 20px;
    display: flex;
    justify-content: space-between;
  }
  button {
    padding: 10px 20px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover {
    background-color: #45a049;
  }
  button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
  }
  #statsPanel {
    margin-top: 20px;
    padding: 10px;
    background-color: #f8f8f8;
    border-radius: 4px;
  }
  #chatBox {
    height: 300px;
    border: 1px solid #ddd;
    overflow-y: scroll;
    padding: 10px;
    margin-top: 20px;
  }
  #chatInput {
    width: calc(100% - 110px);
    padding: 10px;
    margin-top: 10px;
  }
  #sendButton {
    width: 100px;
    margin-left: 10px;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>Advanced P2P Live Streaming Platform</h1>
    <video id="videoElement" autoplay></video>
    <div class="controls">
      <button id="startButton">Start Stream</button>
      <button id="stopButton" disabled>Stop Stream</button>
      <button id="screenShareButton" disabled>Share Screen</button>
      <select id="qualitySelector" disabled>
        <option value="high">High Quality</option>
        <option value="medium">Medium Quality</option>
        <option value="low">Low Quality</option>
      </select>
    </div>
    <div id="statsPanel">
      <h2>Stream Statistics</h2>
      <p>Peer Connections: <span id="peerCount">0</span></p>
      <p>Bandwidth: <span id="bandwidth">0 kbps</span></p>
      <p>Packet Loss: <span id="packetLoss">0%</span></p>
      <p>Resolution: <span id="resolution">-</span></p>
      <p>Frame Rate: <span id="frameRate">0 fps</span></p>
    </div>
    <h2>Live Chat</h2>
    <div id="chatBox"></div>
    <input type="text" id="chatInput" placeholder="Type your message...">
    <button id="sendButton">Send</button>
  </div>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
    const videoElement = document.getElementById('videoElement');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const screenShareButton = document.getElementById('screenShareButton');
    const qualitySelector = document.getElementById('qualitySelector');
    const chatBox = document.getElementById('chatBox');
    const chatInput = document.getElementById('chatInput');
    const sendButton = document.getElementById('sendButton');

    const peerCountElement = document.getElementById('peerCount');
    const bandwidthElement = document.getElementById('bandwidth');
    const packetLossElement = document.getElementById('packetLoss');
    const resolutionElement = document.getElementById('resolution');
    const frameRateElement = document.getElementById('frameRate');

    let peer;
    let stream;
    let connections = [];
    let isStreamer = false;
    let mediaRecorder;
    let chunks = [];
    let statsInterval;

    function initPeer() {
      peer = new Peer({
        config: {'iceServers': [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'turn:numb.viagenie.ca', credential: 'muazkh', username: 'webrtc@live.com' }
        ]}
      });
      
      peer.on('open', (id) => {
        console.log('My peer ID is: ' + id);
        checkExistingStream();
      });

      peer.on('connection', handleNewConnection);

      peer.on('call', (call) => {
        if (isStreamer) {
          call.answer(stream);
        } else {
          call.answer();
        }
        setupMediaConnection(call);
      });
    }

    function handleNewConnection(conn) {
      connections.push(conn);
      updatePeerCount();
      setupDataConnection(conn);

      if (isStreamer) {
        const call = peer.call(conn.peer, stream);
        setupMediaConnection(call);
      }
    }

    function setupMediaConnection(call) {
      call.on('stream', (remoteStream) => {
        if (!isStreamer) {
          videoElement.srcObject = remoteStream;
          startStatsInterval(call.peerConnection);
        }
      });
    }

    function setupDataConnection(conn) {
      conn.on('data', handleIncomingData);
      conn.on('close', () => {
        connections = connections.filter(c => c !== conn);
        updatePeerCount();
      });
    }

    function handleIncomingData(data) {
      switch(data.type) {
        case 'chat':
          addMessageToChat(conn.peer, data.message);
          break;
        case 'quality':
          if (isStreamer) {
            adjustStreamQuality(data.quality);
          }
          break;
      }
    }

    function checkExistingStream() {
      // In a real app, you'd check with a signaling server
      // For this demo, we'll assume no existing stream
      enableStreamerControls();
    }

    function enableStreamerControls() {
      startButton.disabled = false;
      qualitySelector.disabled = false;
    }

    async function startStream() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ 
          audio: true, 
          video: { width: 1280, height: 720 } 
        });
        videoElement.srcObject = stream;
        isStreamer = true;
        startButton.disabled = true;
        stopButton.disabled = false;
        screenShareButton.disabled = false;
        
        setupMediaRecorder();
        broadcastStream();
        startStatsInterval();
      } catch (err) {
        console.error("Error accessing media devices:", err);
      }
    }

    function setupMediaRecorder() {
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9,opus' });
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunks.push(event.data);
          broadcastChunk(event.data);
        }
      };
      mediaRecorder.start(1000); // Collect 1 second of data at a time
    }

    function broadcastStream() {
      connections.forEach(conn => {
        const call = peer.call(conn.peer, stream);
        setupMediaConnection(call);
      });
    }

    function broadcastChunk(chunk) {
      connections.forEach(conn => {
        conn.send({ type: 'media', chunk: chunk });
      });
    }

    function stopStream() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        videoElement.srcObject = null;
        isStreamer = false;
        startButton.disabled = false;
        stopButton.disabled = true;
        screenShareButton.disabled = true;
        qualitySelector.disabled = true;
        
        if (mediaRecorder) {
          mediaRecorder.stop();
        }
        
        connections.forEach(conn => conn.close());
        connections = [];
        updatePeerCount();
        clearInterval(statsInterval);
      }
    }

    async function shareScreen() {
      try {
        const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        videoElement.srcObject = screenStream;
        
        if (isStreamer) {
          const videoTrack = screenStream.getVideoTracks()[0];
          const sender = peer.getSenders().find(s => s.track.kind === 'video');
          sender.replaceTrack(videoTrack);
        }
      } catch (err) {
        console.error("Error sharing screen:", err);
      }
    }

    function sendChatMessage() {
      const message = chatInput.value.trim();
      if (message) {
        broadcastData({ type: 'chat', message: message });
        addMessageToChat('You', message);
        chatInput.value = '';
      }
    }

    function broadcastData(data) {
      connections.forEach(conn => conn.send(data));
    }

    function addMessageToChat(sender, message) {
      const messageElement = document.createElement('p');
      messageElement.textContent = `${sender}: ${message}`;
      chatBox.appendChild(messageElement);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    function updatePeerCount() {
      peerCountElement.textContent = connections.length;
    }

    function adjustStreamQuality(quality) {
      // In a real implementation, you'd adjust video bitrate, resolution, etc.
      console.log(`Adjusting stream quality to: ${quality}`);
    }

    function startStatsInterval(peerConnection) {
      statsInterval = setInterval(() => {
        if (peerConnection) {
          peerConnection.getStats(null).then(stats => {
            stats.forEach(report => {
              if (report.type === 'inbound-rtp' && report.kind === 'video') {
                const bytesNow = report.bytesReceived;
                const packetsLost = report.packetsLost;
                const packetsReceived = report.packetsReceived;

                if (this.lastByteReceived) {
                  const bitrate = 8 * (bytesNow - this.lastByteReceived) / 1000;
                  bandwidthElement.textContent = `${bitrate.toFixed(2)} kbps`;
                }

                this.lastByteReceived = bytesNow;

                const lossRate = packetsLost / (packetsLost + packetsReceived) * 100;
                packetLossElement.textContent = `${lossRate.toFixed(2)}%`;
              }
              if (report.type === 'track' && report.kind === 'video') {
                resolutionElement.textContent = `${report.frameWidth}x${report.frameHeight}`;
                frameRateElement.textContent = `${report.framesPerSecond} fps`;
              }
            });
          });
        }
      }, 1000);
    }

    startButton.addEventListener('click', startStream);
    stopButton.addEventListener('click', stopStream);
    screenShareButton.addEventListener('click', shareScreen);
    sendButton.addEventListener('click', sendChatMessage);
    qualitySelector.addEventListener('change', (e) => {
      if (isStreamer) {
        adjustStreamQuality(e.target.value);
      } else {
        broadcastData({ type: 'quality', quality: e.target.value });
      }
    });

    // Initialize on page load
    initPeer();
  </script>
</body></html>
